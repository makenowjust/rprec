# frozen_string_literal: true

require_relative './stream'

module RPrec

  # `RegexpLexer` is a lexer using regexp patterns.
  class RegexpLexer

    # @param skip [Regexp]
    # @param pattern [Regexp]
    # @param block [Proc]
    def initialize(skip:, pattern:, &block)
      @skip = /\G#{skip}/
      @pattern = /\G#{pattern}/
      @block = block
    end

    # @dynamic skip, pattern, block

    # @return [Regexp]
    attr_reader :skip
    # @return [Regexp]
    attr_reader :pattern
    # @return [Proc]
    attr_reader :block

    # @param source [String]
    # @return [RPrec::RegexpStream]
    def lex(source)
      RegexpStream.new(self, source)
    end
  end

  # `RegexpStream` is a stream generated by a `RegexpLexer`.
  #
  # @api private
  class RegexpStream < Stream

    # @param lexer [RPrec::Lexer]
    # @param source [String]
    def initialize(lexer, source)
      super()
      @lexer = lexer
      @source = source
      @offset = 0
      self.next
    end

    # @return [RPrec::Token]
    def current
      @current
    end    

    # @return [void]
    def next
      super

      skip = @source.match(@lexer.skip, @offset)
      @offset += skip.to_s.size if skip

      if eof?
        @current = Token.new('EOF', loc: @offset...@offset)
        return
      end

      match = @source.match(@lexer.pattern, @offset)
      unless match
        raise ParseError.new("Unexpected character: #{@source[@offset].inspect}", loc: @offset...@offset+1)
      end

      type_and_value = @lexer.block.call(match)
      type, value =
        if type_and_value.is_a?(Array)
          [type_and_value[0], type_and_value[1]]
        else
          [type_and_value, nil]
        end
      loc = @offset...@offset+match.to_s.size
      @offset += match.to_s.size
      @current = Token.new(type, value, loc:)
    end

    # @return [Boolean]
    def eof?
      @source.size <= @offset
    end
  end
end
